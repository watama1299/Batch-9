class Program {
    static async Task Main(string[] args) {
        Console.WriteLine("Main method started");



        // CancellationTokenSource listen for any threads that calls it
        // If any threads call the Cancel method, it will update its Token property
        CancellationTokenSource cts = new();



        // CancellationToken keeps track of the Token in the Source
        // Threads can listen to any changes in the Token thru this
        CancellationToken token = cts.Token;



        Task t1 = Task.Run(() => Printer(token));
        Task.Run(() => UserInputCheck(cts));



        // When a Task is cancelled using the Token, it will result in an TaskCanceledException
        // Any task that is keeping track of Token need to be put in try/catch
        // so that it can handle the Exception generated by the cancellation of the task
        // await t1;
        try {
            await t1;
        } catch (Exception) {
            Console.WriteLine("Printer interrupted");
        }

        Console.WriteLine("Main method ended");
    }

    static async Task Printer(CancellationToken token) {
        for (int i = 0; i < 100; i++) {
            Console.WriteLine(i + "%");



            // Task.Delay method overloading
            // Adding the token as the parameter to the method
            await Task.Delay(100, token);

            
        }
        Console.WriteLine("Done");
    }

    static void UserInputCheck(CancellationTokenSource cts) {
        if (Console.ReadKey().Key == ConsoleKey.Spacebar) {
            cts.Cancel();
        }
    }
}